{% macro carousel_item(content, name, role, avatar_img_src='' ) -%}
<div class="testimonial">
  <span class="quote-mark"></span>
  <div class="testimonial-content">
    <p class="testimonial-text">
      {{ content }}
    </p>
    <div class="testimonial-attribution">
      <img class="attribution-avatar" src="{{ avatar_img_src }}" alt="{{ name }}">
      <h4 class="attribution-name">{{ name }}</h4>
      <span class="attribution-role">{{ role }}</span>
    </div>
  </div>
</div>
{% endmacro %}

{% macro carousel_footer() -%}
<div class="testimonials-progress"></div>
<script>
  (function () {
    const SLIDE_INTERVAL_MS = 8000;

    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const swipeThreshold = 50; // Minimum distance for a swipe

    const track = document.querySelector('.testimonials-track');
    const testimonials = document.querySelectorAll('.testimonial');
    const progressContainer = document.querySelector('.testimonials-progress');
    const slider = document.querySelector('.testimonials-slider');

    let currentIndex = 0;

    // Sets slider state based on the value of currentIndex.
    function updateSlider() {
      const testimonial = testimonials[currentIndex];
      const sliderWidth = document.querySelector('.testimonials-slider').offsetWidth;
      const testimonialWidth = testimonial.offsetWidth;

      const gap = parseInt(getComputedStyle(track).gap) || 0;

      const centerOffset = (sliderWidth - testimonialWidth) / 2;
      const testimonialOffset = currentIndex * (testimonialWidth + gap);
      const offset = centerOffset - testimonialOffset;

      track.style.transform = `translateX(${offset}px)`;

      // Enable .active class only for current testimonial.
      testimonials.forEach((testimonial, index) => {
        testimonial.classList.toggle('active', index === currentIndex);
      });

      // Update dots
      const dots = document.querySelectorAll('.progress-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', index === currentIndex);
      });
    }

    // function nextTestimonial() {
    //   currentIndex = (currentIndex + 1) % testimonials.length;
    //   updateSlider();
    // }

    // function prevTestimonial() {
    //   currentIndex = (currentIndex - 1 + testimonials.length) % testimonials.length;
    //   updateSlider();
    // }

    function nextTestimonial() {
      if (currentIndex < testimonials.length - 1) {
        currentIndex++;
        updateSlider();
      }
    }

    function prevTestimonial() {
      if (currentIndex > 0) {
        currentIndex--;
        updateSlider();
      }
    }

    function createDots() {
      progressContainer.innerHTML = '';
      testimonials.forEach((_, index) => {
        const dot = document.createElement('button');
        dot.classList.add('progress-dot');
        dot.setAttribute('aria-label', `Go to testimonial ${index + 1}`);

        if (index === 0) {
          dot.classList.add('active');
        }

        dot.addEventListener('click', () => {
          currentIndex = index;
          updateSlider();
          // clearTimeout(timeout);
          // startAutoAdvance();
        });
        progressContainer.appendChild(dot);
      });
    }

    function handleSwipe() {
      const swipeDistance = touchEndX - touchStartX;

      if (Math.abs(swipeDistance) > swipeThreshold) {
        if (swipeDistance > 0) {
          // Swiped right - go to previous
          prevTestimonial();
        } else {
          // Swiped left - go to next
          nextTestimonial();
        }
      }
    }

    function startAutoAdvance() {
      timeout = setTimeout(() => {
        nextTestimonial();
        startAutoAdvance(); // Recursively continue advancing
      }, SLIDE_INTERVAL_MS);
    }

    // Add click and swipe handlers.
    let timeout; // For auto-advance, not currently used.

    // Initialize click handler on each testimonial.
    testimonials.forEach((testimonial, index) => {
      testimonial.addEventListener('click', () => {
        currentIndex = index;
        updateSlider();

        // clearTimeout(timeout);
        // startAutoAdvance();
      })
    });

    slider.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });

    slider.addEventListener('touchmove', (e) => {
      const touchCurrentX = e.changedTouches[0].screenX;
      const touchCurrentY = e.changedTouches[0].screenY;

      const deltaX = Math.abs(touchCurrentX - touchStartX);
      const deltaY = Math.abs(touchCurrentY - touchStartY);

      // If swipe is more horizontal than vertical, prevent page scroll
      if (deltaX > deltaY) {
        e.preventDefault();
      }
    }); // Note: NOT passive, so we can call preventDefault

    slider.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;
      handleSwipe();
    }, { passive: true });


    // Initialize
    updateSlider();
    createDots();
    // startAutoAdvance();

    // Recalculate on resize
    window.addEventListener('resize', updateSlider);
  })()

</script>
{% endmacro %}
