{% macro carousel_item(content, name, role, avatar_img_src='' ) -%}
<div class="testimonial">
  <span class="quote-mark"></span>
  <div class="testimonial-content">
    <p class="testimonial-text">
      {{ content }}
    </p>
    <div class="testimonial-attribution">
      <img class="attribution-avatar" src="{{ avatar_img_src }}" alt="{{ name }}">
      <h4 class="attribution-name">{{ name }}</h4>
      <span class="attribution-role">{{ role }}</span>
    </div>
  </div>
</div>
{% endmacro %}

{% macro carousel_footer() -%}
<div class="testimonials-progress"></div>
<script>
  (function () {
    const SLIDE_INTERVAL_MS = 8000;

    let currentIndex = 0;

    const track = document.querySelector('.testimonials-track');
    const testimonials = document.querySelectorAll('.testimonial');
    const progressContainer = document.querySelector('.testimonials-progress');
    const slider = document.querySelector('.testimonials-slider');

    // Touch/swipe handling
    let touchStartX = 0;
    let touchStartY = 0;
    let touchCurrentX = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    let isDragging = false;
    let initialTransform = 0;
    let touchStartTime = 0;
    let lastTouchTime = 0;
    let lastTouchX = 0;
    const swipeThreshold = 50; // Minimum distance for a swipe
    const velocityThreshold = 0.5; // Minimum velocity (pixels/ms) for a quick swipe
    const rubberBandResistance = 3; // Higher = more resistance at edges


    // Sets slider state based on the value of currentIndex.
    function updateSlider() {
      const testimonial = testimonials[currentIndex];
      const sliderWidth = document.querySelector('.testimonials-slider').offsetWidth;
      const testimonialWidth = testimonial.offsetWidth;

      const gap = parseInt(getComputedStyle(track).gap) || 0;

      const centerOffset = (sliderWidth - testimonialWidth) / 2;
      const testimonialOffset = currentIndex * (testimonialWidth + gap);
      const offset = centerOffset - testimonialOffset;

      track.style.transform = `translateX(${offset}px)`;

      // Enable .active class only for current testimonial.
      testimonials.forEach((testimonial, index) => {
        testimonial.classList.toggle('active', index === currentIndex);
      });

      // Update dots
      const dots = document.querySelectorAll('.progress-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', index === currentIndex);
      });
    }

    function nextTestimonial() {
      if (currentIndex < testimonials.length - 1) {
        currentIndex++;
        updateSlider();
      }
    }

    function prevTestimonial() {
      if (currentIndex > 0) {
        currentIndex--;
        updateSlider();
      }
    }

    function createDots() {
      progressContainer.innerHTML = '';
      testimonials.forEach((_, index) => {
        const dot = document.createElement('button');
        dot.classList.add('progress-dot');
        dot.setAttribute('aria-label', `Go to testimonial ${index + 1}`);

        if (index === 0) {
          dot.classList.add('active');
        }

        dot.addEventListener('click', () => {
          currentIndex = index;
          updateSlider();
          // clearTimeout(timeout);
          // startAutoAdvance();
        });
        progressContainer.appendChild(dot);
      });
    }

    function calculateVelocity() {
      const timeDiff = Date.now() - lastTouchTime;
      const distDiff = touchEndX - lastTouchX;

      if (timeDiff === 0) return 0;
      return distDiff / timeDiff; // pixels per millisecond
    }

    function applyRubberBand(dragDistance) {
      const testimonial = testimonials[currentIndex];
      const testimonialWidth = testimonial.offsetWidth;
      const gap = parseInt(getComputedStyle(track).gap) || 0;

      // Check if we're at boundaries
      const atStart = currentIndex === 0 && dragDistance > 0;
      const atEnd = currentIndex === testimonials.length - 1 && dragDistance < 0;

      if (atStart || atEnd) {
        // Apply rubber band effect - the further you drag, the more resistance
        return dragDistance / rubberBandResistance;
      }

      return dragDistance;
    }

    function handleSwipe() {
      const swipeDistance = touchEndX - touchStartX;
      const velocity = calculateVelocity();

      // Determine if we should change slides based on swipe distance OR velocity
      const shouldChangeSlide = Math.abs(swipeDistance) > swipeThreshold || Math.abs(velocity) > velocityThreshold;

      if (shouldChangeSlide) {
        // Calculate dynamic transition duration based on velocity
        // Faster swipes = shorter duration
        let duration = 0.5; // default
        if (Math.abs(velocity) > velocityThreshold) {
          // Map velocity to duration: faster velocity = shorter duration
          // Clamp between 0.2s (very fast) and 0.5s (slow)
          duration = Math.max(0.2, Math.min(0.5, 0.5 / Math.abs(velocity)));
        }

        track.style.transition = `transform ${duration}s ease-out`;

        if (swipeDistance > 0 && currentIndex > 0) {
          // Swiped right - go to previous
          prevTestimonial();
        } else if (swipeDistance < 0 && currentIndex < testimonials.length - 1) {
          // Swiped left - go to next
          nextTestimonial();
        } else {
          // At boundary - snap back with bounce effect
          updateSlider();
        }
      } else {
        // Did not meet threshold - snap back with normal speed
        track.style.transition = 'transform 0.3s ease-out';
        updateSlider();
      }
    }

    function startAutoAdvance() {
      timeout = setTimeout(() => {
        nextTestimonial();
        startAutoAdvance(); // Recursively continue advancing
      }, SLIDE_INTERVAL_MS);
    }

    // Add click and swipe handlers.
    let timeout; // For auto-advance, not currently used.

    // Initialize click handler on each testimonial.
    testimonials.forEach((testimonial, index) => {
      testimonial.addEventListener('click', () => {
        currentIndex = index;
        updateSlider();

        // clearTimeout(timeout);
        // startAutoAdvance();
      })
    });


    slider.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
      lastTouchX = touchStartX;
      touchStartTime = Date.now();
      lastTouchTime = touchStartTime;
      isDragging = true;

      // Store the current transform value
      const currentTransform = track.style.transform;
      const match = currentTransform.match(/translateX\(([^)]+)px\)/);
      initialTransform = match ? parseFloat(match[1]) : 0;

      // Temporarily disable transition for smooth dragging
      track.style.transition = 'none';
    }, { passive: true });

    slider.addEventListener('touchmove', (e) => {
      if (!isDragging) return;

      touchCurrentX = e.changedTouches[0].screenX;
      const touchCurrentY = e.changedTouches[0].screenY;

      const deltaX = Math.abs(touchCurrentX - touchStartX);
      const deltaY = Math.abs(touchCurrentY - touchStartY);

      // If swipe is more horizontal than vertical, prevent page scroll
      if (deltaX > deltaY) {
        e.preventDefault();

        // Update velocity tracking
        lastTouchTime = Date.now();
        lastTouchX = touchCurrentX;

        // Calculate drag distance with rubber band effect
        const rawDragDistance = touchCurrentX - touchStartX;
        const dragDistance = applyRubberBand(rawDragDistance);

        track.style.transform = `translateX(${initialTransform + dragDistance}px)`;
      }
    });

    slider.addEventListener('touchend', (e) => {
      if (!isDragging) return;

      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;
      isDragging = false;

      // Transition is now set in handleSwipe() based on velocity
      handleSwipe();
    }, { passive: true });


    // Initialize
    updateSlider();
    createDots();
    // startAutoAdvance();

    // Recalculate on resize
    window.addEventListener('resize', updateSlider);
  })()

</script>
{% endmacro %}
